%{
/*
File "parser.ypp"

blahtex (version 0.2.1): a LaTeX to MathML converter designed specifically for MediaWiki
Copyright (C) 2005, David Harvey

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "blahtex.h"

/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Parsing stuff */

bool in_text_mode = false;

/* The root of the parse tree. This needs to be global because yyparse() is a global function
(which is yacc's fault). */
parse_math* parse_root;

// Error function called by yyparse()
void yyerror(const char *s) {
	throw user_error(L"Parsing error: " + convert_utf8_to_wchar_t(s));
}

%}

%union {
	parse_node*            symbol_node;
	parse_text*            symbol_test;
	parse_math*            symbol_math;
	parse_math_atom*       symbol_math_atom;
	parse_math_script*     symbol_math_script;
	parse_math_scripts*    symbol_math_scripts;
	parse_math_table_row*  symbol_math_table_row;
	parse_math_table*      symbol_math_table;
	wstring*               terminal_string;
}

/*
 Tokens starting with "t_" only occur in text mode.
 Tokens starting with "m_" only occur in math mode.
 "yylex" decides which kind to emit depending on the current value of "in_text_mode".
*/

%nonassoc       LOWEST_PRECEDENCE	/* never actually seen by parser */
%token          END_OF_INPUT
%token          INVALID				/* never actually seen by parser */

/*
t_ATOM covers all text atoms: individual characters (including unicode), escaped characters
like "\&", and spacing commands (e.g. "\quad").

t_BEGIN_GROUP and t_END_GROUP are the opening/closing grouping braces in text mode.
t_DECLARATION is things in text mode like "\bf" which apply until the end of block.
t_COMMAND_1ARG covers commands in text mode like "\textbf" which take one argument.
*/
%token <terminal_string>  t_ATOM
%token                    t_BEGIN_GROUP
%token                    t_END_GROUP
%token <terminal_string>  t_DECLARATION
%token <terminal_string>  t_COMMAND_1ARG

/*
m_ATOM covers all math atoms: individual characters (including unicode), escaped characters
like "\&", spacing commands (e.g. "\quad"), symbols like "\alpha" or "\sin" or "\infty", operators
like "+" or "\lim", numerals like "5".

m_BEGIN_GROUP and m_END_GROUP are the opening/closing grouping braces in math mode.
m_DECLARATION is things in math mode like "\bf" which apply until the end of block.
*/
%token <terminal_string>  m_ATOM
%token                    m_BEGIN_GROUP
%token                    m_END_GROUP
%token <terminal_string>  m_DECLARATION

/*
m_SUBSCRIPT is the "_" character in math mode.
m_SUPERSCRIPT is the "^" character in math mode.
m_PRIME is the "'" character in math mode.
  Note there is special treatment for m_PRIME to ensure that "A'" is interpreted as a prime
  adjoined to A rather than two separate atoms.
m_LIMITS covers commands like "\limits" and "\nolimits" which must appear right before some scripts.
*/
%token                    m_SUBSCRIPT
%token                    m_SUPERSCRIPT
%nonassoc                 m_PRIME
%token <terminal_string>  m_LIMITS

/* m_LEFT and m_RIGHT are the "\left" and "\right" commands. */
%token                    m_LEFT
%token                    m_RIGHT

/*
m_COMMAND_INFIX is any infix command in math mode, like "\over" or "\choose".
m_COMMAND_1ARG is a command in math mode with one argument, like "\mathop" or "\hat".
m_COMMAND_2ARGS is a command in math mode with two arguments, like "\frac".

m_COMMAND_1OPT_1ARG is actually is never seen by the parser; yylex() translates it to m_COMMAND_1ARG
or m_COMMAND_2ARGS, depending on whether an optional argument is present. */

%token <terminal_string>  m_COMMAND_INFIX
%token <terminal_string>  m_COMMAND_1ARG
%token <terminal_string>  m_COMMAND_2ARGS
%token                    m_COMMAND_1OPT_1ARG

/*
m_NEXT_CELL is the "&" command in math mode.
m_NEXT_ROW is the "\\" command in math mode.
*/
%token                    m_NEXT_CELL
%token                    m_NEXT_ROW

/*
m_BEGIN_ENVIRONMENT covers tokens in math mode like "\begin{pmatrix}".
m_END_ENVIRONMENT is similar.
m_ENVIRONMENT covers commands like "\pmatrix", which take one argument (which must be a table).
*/
%token <terminal_string>  m_BEGIN_ENVIRONMENT
%token <terminal_string>  m_END_ENVIRONMENT
%token <terminal_string>  m_ENVIRONMENT

/* m_ENTER_TEXT_MODE covers commands in math mode that switch to text mode, like "\textrm". */
%token <terminal_string>  m_ENTER_TEXT_MODE

%type <symbol_math>            final_expression
%type <symbol_math>            expression
%type <symbol_math>            nonempty_expression
%type <symbol_math>            unfinished_nonempty_expression
%type <symbol_math>            declaration
%type <symbol_math>            expression_piece
%type <symbol_math_scripts>    argument_with_scripts
%type <symbol_math_script>     script
%type <symbol_math>            argument
%type <symbol_math_table>      table
%type <symbol_math_table_row>  table_row
%type <terminal_string>        enter_text_mode
%type <symbol_test>            text_expression
%type <symbol_test>            unfinished_text_expression
%type <symbol_test>            text_argument

%%

final_expression
	: expression  END_OF_INPUT
		{ parse_root = $$ = $1; }

	/* We have to allow things like "a \over b" at this top level, because the only other place
	where we parse m_COMMAND_INFIX is in the rules for "argument" where we require curly braces,
	like this: "{a \over b}". */
	| nonempty_expression  m_COMMAND_INFIX  nonempty_expression  END_OF_INPUT
		{ parse_root = $$ = new parse_math_command_2args(*($2), $1, $3); }


expression
	: /* */
		{ $$ = new parse_math_empty; }
	
	| nonempty_expression
		{ $$ = $1; }

	
nonempty_expression
	: unfinished_nonempty_expression
		{ $$ = $1; }
		
	| unfinished_nonempty_expression  declaration
		{ $$ = new parse_math_join($1, $2); }
	
	| declaration
		{ $$ = $1; }

	
unfinished_nonempty_expression
	: expression_piece
		{ $$ = $1; }
	
	| unfinished_nonempty_expression  expression_piece
		{ $$ = new parse_math_join($1, $2); }

		
declaration
	: m_DECLARATION  expression
		{ $$ = new parse_math_command_1arg(*($1), $2); }

	
expression_piece
	/* The precedence declaration here ensures that "A'" is interpreted as a prime adjoined to A,
	rather than two consecutive atoms; i.e. when we see the "'" we shift instead of reducing via
	this rule */
	: argument_with_scripts         %prec LOWEST_PRECEDENCE	
		{ $$ = ($1->scripts.empty() && $1->limits.empty()) ? $1->base : $1; }

	
argument_with_scripts
	/* This rule is a little inefficient, but what the heck, it makes life easier. In something 
	like "abc", the atom "a" gets wrapped momentarily in a "parse_scripts" node, which gets peeled
	off again by the rule (argument_with_scripts => expression_piece). */
	: argument
		{ $$ = new parse_math_scripts($1); }
	
	| argument  m_LIMITS
		{ $$ = new parse_math_scripts($1, *($2)); }

	/* Notice here we don't guard against double superscript, subscripts, etc. This gets handled
	later while building the layout tree. There are complications involving primes which are
	better handled there. */
	| argument_with_scripts  script
		{ $$ = $1; $$->scripts.push_back($2); }
	
		
script
	: m_PRIME
		{ $$ = new parse_math_prime; }
	
	| m_SUBSCRIPT argument
		{ $$ = new parse_math_subscript($2); }

	| m_SUPERSCRIPT argument
		{ $$ = new parse_math_superscript($2); }


/* An "argument" is something recognised as a single argument to a latex command. For example,
"ab" is *not* an argument, because in "x^ab", the superscript only applies to the "a". */
argument
	: m_ATOM
		{ $$ = new parse_math_atom(*($1)); }

	/* Here we are treating the prime character as an atom.
	(NB: see precedence declaration on "expression_piece") */
	| m_PRIME
		{ $$ = new parse_math_atom(L"\'"); }

	| m_LEFT  m_ATOM  expression  m_RIGHT  m_ATOM
		{ $$ = new parse_math_delimited(
				$3, new parse_math_atom(*($2)), new parse_math_atom(*($5))); }
		
	| m_ENVIRONMENT  m_BEGIN_GROUP  table  m_END_GROUP
		{
			wstring label = *($1);
			/* Remove initial backslash, e.g. "\pmatrix" becomes "pmatrix" */
			label.erase(label.begin());
			$$ = new parse_math_environment(label, $3);
		}
		
	| m_BEGIN_ENVIRONMENT  table  m_END_ENVIRONMENT
		{
			/* Check begin and end environments match */
			wstring begin_label = $1->substr(7, $1->size() - 8);
			wstring end_label   = $3->substr(5, $3->size() - 6);
			if (begin_label != end_label) throw user_error(
				L"The command \"" + *($1) + L"\" does not match \"" + *($3) + L"\".");
			$$ = new parse_math_environment(begin_label, $2);
		}
			
	| m_COMMAND_1ARG  argument
		{ $$ = new parse_math_command_1arg(*($1), $2); }
						  
	| m_COMMAND_2ARGS  argument  argument
		{ $$ = new parse_math_command_2args(*($1), $2, $3); }

	/* We treat infix commands simply as commands with two arguments.
	Note we insist on the surrounding braces, to prevent ambiguities in expressions like
	"a \over b \over c". */
	| m_BEGIN_GROUP  nonempty_expression  m_COMMAND_INFIX  nonempty_expression  m_END_GROUP
		{ $$ = new parse_math_command_2args(*($3), $2, $4); }
		
	| m_BEGIN_GROUP  expression  m_END_GROUP
		{ $$ = $2; }
		
	| enter_text_mode  text_argument
		{ $$ = new parse_enter_text_mode(*($1), $2); in_text_mode = false; }


/* "enter_text_mode" is a dummy variable that ensures that we switch into text mode at the
correct time */
enter_text_mode
	: m_ENTER_TEXT_MODE
		{ $$ = $1; in_text_mode = true; }	

	
table
	: table_row
		{ $$ = new parse_math_table($1); }
	
	| table  m_NEXT_ROW  table_row
		{ $$ = $1; $$->rows.push_back($3); }

	
table_row
	: expression
		{ $$ = new parse_math_table_row($1); }
			
	| table_row  m_NEXT_CELL  expression
		{ $$ = $1; $$->entries.push_back($3); }


text_expression
	: unfinished_text_expression
		{ $$ = $1; }
	
	| unfinished_text_expression  t_DECLARATION  text_expression
		{ $$ = new parse_text_join($1, new parse_text_command_1arg(*($2), $3)); }

		
unfinished_text_expression
	: /* */
		{ $$ = new parse_text_empty; }

	| unfinished_text_expression  text_argument
		{ $$ = new parse_text_join($1, $2); }

		
text_argument
	: t_ATOM
		{ $$ = new parse_text_atom(*($1)); }
	
	| t_BEGIN_GROUP  text_expression  t_END_GROUP
		{ $$ = $2; }
	
	| t_COMMAND_1ARG  text_argument
		{ $$ = new parse_text_command_1arg(*($1), $2); }

%%

/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Some lookup tables */

/* This table tells yylex() what kind of token to produce for the various latex commands and
special characters. The first column is the token code that should be produced in math mode, the
second column is the code for text mode. */

dictionary_item<latex_command_info> latex_command_data[] = {
		
	// ------------ Special stuff
		
	{L"{",               {m_BEGIN_GROUP,        t_BEGIN_GROUP}},
	{L"}",               {m_END_GROUP,          t_END_GROUP}},
	{L"&",               {m_NEXT_CELL,          INVALID}},
	{L"\\\\",            {m_NEXT_ROW,           INVALID}},
	{L"^",               {m_SUPERSCRIPT,        INVALID}},
	{L"_",               {m_SUBSCRIPT,          INVALID}},
	{L"'",               {m_PRIME,              t_ATOM}},
		
	{L"\\_",             {m_ATOM,               t_ATOM}},
	{L"\\&",             {m_ATOM,               t_ATOM}},
	{L"\\$",             {m_ATOM,               t_ATOM}},
	{L"\\#",             {m_ATOM,               t_ATOM}},
	{L"\\%",             {m_ATOM,               t_ATOM}},
	{L"\\textbackslash", {INVALID,              t_ATOM}},
	{L"\\{",             {m_ATOM,               t_ATOM}},
	{L"\\}",             {m_ATOM,               t_ATOM}},
		
	{L"\\sqrt",          {m_COMMAND_1OPT_1ARG,  INVALID}},
		
	{L"\\frac",          {m_COMMAND_2ARGS,      INVALID}},
	{L"\\over",          {m_COMMAND_INFIX,      INVALID}},
	{L"\\binom",         {m_COMMAND_2ARGS,      INVALID}},
	{L"\\choose",        {m_COMMAND_INFIX,      INVALID}},
	{L"\\atop",          {m_COMMAND_INFIX,      INVALID}},
		
	{L"\\left",          {m_LEFT,               INVALID}},
	{L"\\right",         {m_RIGHT,              INVALID}},
		
	{L"\\big",           {m_COMMAND_1ARG,       INVALID}},
	{L"\\Big",           {m_COMMAND_1ARG,       INVALID}},
	{L"\\bigg",          {m_COMMAND_1ARG,       INVALID}},
	{L"\\Bigg",          {m_COMMAND_1ARG,       INVALID}},
		
	{L"\\mod",           {m_COMMAND_1ARG,       INVALID}},
	{L"\\pmod",          {m_COMMAND_1ARG,       INVALID}},
	{L"\\bmod",          {m_COMMAND_1ARG,       INVALID}},
		
	{L"\\mathop",        {m_COMMAND_1ARG,       INVALID}},
	{L"\\not",           {m_COMMAND_1ARG,       INVALID}},
		
	{L"\\operatorname",  {m_COMMAND_1ARG,       INVALID}},
		
	{L"\\limits",        {m_LIMITS,             INVALID}},
	{L"\\nolimits",      {m_LIMITS,             INVALID}},
	{L"\\displaylimits", {m_LIMITS,             INVALID}},
		
	// ------------- Matrices
		
	{L"\\matrix",     {m_ENVIRONMENT,       INVALID}},
	{L"\\pmatrix",    {m_ENVIRONMENT,       INVALID}},
	{L"\\bmatrix",    {m_ENVIRONMENT,       INVALID}},
	{L"\\Bmatrix",    {m_ENVIRONMENT,       INVALID}},
	{L"\\vmatrix",    {m_ENVIRONMENT,       INVALID}},
	{L"\\Vmatrix",    {m_ENVIRONMENT,       INVALID}},
	{L"\\cases",      {m_ENVIRONMENT,       INVALID}},
		
	{L"\\begin{matrix}",     {m_BEGIN_ENVIRONMENT,       INVALID}},
	{L"\\begin{pmatrix}",    {m_BEGIN_ENVIRONMENT,       INVALID}},
	{L"\\begin{bmatrix}",    {m_BEGIN_ENVIRONMENT,       INVALID}},
	{L"\\begin{Bmatrix}",    {m_BEGIN_ENVIRONMENT,       INVALID}},
	{L"\\begin{vmatrix}",    {m_BEGIN_ENVIRONMENT,       INVALID}},
	{L"\\begin{Vmatrix}",    {m_BEGIN_ENVIRONMENT,       INVALID}},
	{L"\\begin{cases}",      {m_BEGIN_ENVIRONMENT,       INVALID}},
		
	{L"\\end{matrix}",     {m_END_ENVIRONMENT,       INVALID}},
	{L"\\end{pmatrix}",    {m_END_ENVIRONMENT,       INVALID}},
	{L"\\end{bmatrix}",    {m_END_ENVIRONMENT,       INVALID}},
	{L"\\end{Bmatrix}",    {m_END_ENVIRONMENT,       INVALID}},
	{L"\\end{vmatrix}",    {m_END_ENVIRONMENT,       INVALID}},
	{L"\\end{Vmatrix}",    {m_END_ENVIRONMENT,       INVALID}},
	{L"\\end{cases}",      {m_END_ENVIRONMENT,       INVALID}},
		
	// ------------- Spacing
		
	{L"~",            {m_ATOM,    t_ATOM}},
	{L"\\,",          {m_ATOM,    t_ATOM}},
	{L"\\!",          {m_ATOM,    t_ATOM}},
	{L"\\ ",          {m_ATOM,    t_ATOM}},
	{L"\\;",          {m_ATOM,    t_ATOM}},
	{L"\\quad",       {m_ATOM,    t_ATOM}},
	{L"\\qquad",      {m_ATOM,    t_ATOM}},
		
	// ------------ Delimiters
		
	{L"\\vert",          {m_ATOM,    INVALID}},
	{L"\\Vert",          {m_ATOM,    INVALID}},
	{L"\\lfloor",        {m_ATOM,    INVALID}},
	{L"\\rfloor",        {m_ATOM,    INVALID}},
	{L"\\lceil",         {m_ATOM,    INVALID}},
	{L"\\rceil",         {m_ATOM,    INVALID}},
	{L"\\lbrace",        {m_ATOM,    INVALID}},
	{L"\\rbrace",        {m_ATOM,    INVALID}},
	{L"\\langle",        {m_ATOM,    INVALID}},
	{L"\\rangle",        {m_ATOM,    INVALID}},
	{L"\\lbrack",        {m_ATOM,    INVALID}},
	{L"\\rbrack",        {m_ATOM,    INVALID}},
		
	// ------------ Accents
		
	{L"\\hat",                    {m_COMMAND_1ARG,    INVALID}},
	{L"\\widehat",                {m_COMMAND_1ARG,    INVALID}},
	{L"\\dot",                    {m_COMMAND_1ARG,    INVALID}},
	{L"\\ddot",                   {m_COMMAND_1ARG,    INVALID}},
	{L"\\bar",                    {m_COMMAND_1ARG,    INVALID}},
	{L"\\overline",               {m_COMMAND_1ARG,    INVALID}},
	{L"\\underline",              {m_COMMAND_1ARG,    INVALID}},
	{L"\\overbrace",              {m_COMMAND_1ARG,    INVALID}},
	{L"\\underbrace",             {m_COMMAND_1ARG,    INVALID}},
	{L"\\overleftarrow",          {m_COMMAND_1ARG,    INVALID}},
	{L"\\overrightarrow",         {m_COMMAND_1ARG,    INVALID}},
	{L"\\overleftrightarrow",     {m_COMMAND_1ARG,    INVALID}},
	{L"\\check",                  {m_COMMAND_1ARG,    INVALID}},
	{L"\\acute",                  {m_COMMAND_1ARG,    INVALID}},
	{L"\\grave",                  {m_COMMAND_1ARG,    INVALID}},
	{L"\\vec",                    {m_COMMAND_1ARG,    INVALID}},
	{L"\\breve",                  {m_COMMAND_1ARG,    INVALID}},
	{L"\\tilde",                  {m_COMMAND_1ARG,    INVALID}},
	{L"\\widetilde",              {m_COMMAND_1ARG,    INVALID}},
		
	// ------------ Text mode and fonts
		
	{L"\\textit",     {m_ENTER_TEXT_MODE,     t_COMMAND_1ARG}},
	{L"\\emph",       {m_ENTER_TEXT_MODE,     t_COMMAND_1ARG}},
	{L"\\mbox",       {m_ENTER_TEXT_MODE,     t_COMMAND_1ARG}},
	{L"\\textrm",     {m_ENTER_TEXT_MODE,     t_COMMAND_1ARG}},
	{L"\\textbf",     {m_ENTER_TEXT_MODE,     t_COMMAND_1ARG}},
	{L"\\texttt",     {m_ENTER_TEXT_MODE,     t_COMMAND_1ARG}},
	{L"\\textsf",     {m_ENTER_TEXT_MODE,     t_COMMAND_1ARG}},
		
	{L"\\mathrm",     {m_COMMAND_1ARG,    INVALID}},
	{L"\\mathbf",     {m_COMMAND_1ARG,    INVALID}},
	{L"\\mathbb",     {m_COMMAND_1ARG,    INVALID}},
	{L"\\mathit",     {m_COMMAND_1ARG,    INVALID}},
	{L"\\mathcal",    {m_COMMAND_1ARG,    INVALID}},
	{L"\\mathfrak",   {m_COMMAND_1ARG,    INVALID}},
	{L"\\mathtt",     {m_COMMAND_1ARG,    INVALID}},
	{L"\\boldsymbol", {m_COMMAND_1ARG,    INVALID}},
	{L"\\mathsf",     {m_COMMAND_1ARG,    INVALID}},
		
	{L"\\rm",         {m_DECLARATION,     t_DECLARATION}},
	{L"\\bf",         {m_DECLARATION,     t_DECLARATION}},
	{L"\\it",         {m_DECLARATION,     t_DECLARATION}},
	{L"\\cal",        {m_DECLARATION,     t_DECLARATION}},
	{L"\\tt",         {m_DECLARATION,     t_DECLARATION}},
	{L"\\sf",         {m_DECLARATION,     t_DECLARATION}},
		
	// ------------ Lowercase greek letters
		
	{L"\\alpha",       {m_ATOM,    INVALID}},
	{L"\\beta",        {m_ATOM,    INVALID}},
	{L"\\gamma",       {m_ATOM,    INVALID}},
	{L"\\delta",       {m_ATOM,    INVALID}},
	{L"\\epsilon",     {m_ATOM,    INVALID}},
	{L"\\varepsilon",  {m_ATOM,    INVALID}},
	{L"\\zeta",        {m_ATOM,    INVALID}},
	{L"\\eta",         {m_ATOM,    INVALID}},
	{L"\\theta",       {m_ATOM,    INVALID}},
	{L"\\vartheta",    {m_ATOM,    INVALID}},
	{L"\\iota",        {m_ATOM,    INVALID}},
	{L"\\kappa",       {m_ATOM,    INVALID}},
	{L"\\varkappa",    {m_ATOM,    INVALID}},
	{L"\\lambda",      {m_ATOM,    INVALID}},
	{L"\\mu",          {m_ATOM,    INVALID}},
	{L"\\nu",          {m_ATOM,    INVALID}},
	{L"\\pi",          {m_ATOM,    INVALID}},
	{L"\\varpi",       {m_ATOM,    INVALID}},
	{L"\\rho",         {m_ATOM,    INVALID}},
	{L"\\varrho",      {m_ATOM,    INVALID}},
	{L"\\sigma",       {m_ATOM,    INVALID}},
	{L"\\varsigma",    {m_ATOM,    INVALID}},
	{L"\\tau",         {m_ATOM,    INVALID}},
	{L"\\upsilon",     {m_ATOM,    INVALID}},
	{L"\\phi",         {m_ATOM,    INVALID}},
	{L"\\varphi",      {m_ATOM,    INVALID}},
	{L"\\chi",         {m_ATOM,    INVALID}},
	{L"\\psi",         {m_ATOM,    INVALID}},
	{L"\\omega",       {m_ATOM,    INVALID}},
	{L"\\xi",          {m_ATOM,    INVALID}},	
	{L"\\digamma",     {m_ATOM,    INVALID}},
		
	// ------------ Uppercase greek letters
		
	{L"\\Alpha",       {m_ATOM,    INVALID}},
	{L"\\Beta",        {m_ATOM,    INVALID}},
	{L"\\Gamma",       {m_ATOM,    INVALID}},
	{L"\\Delta",       {m_ATOM,    INVALID}},
	{L"\\Epsilon",     {m_ATOM,    INVALID}},
	{L"\\Zeta",        {m_ATOM,    INVALID}},
	{L"\\Eta",         {m_ATOM,    INVALID}},
	{L"\\Theta",       {m_ATOM,    INVALID}},
	{L"\\Iota",        {m_ATOM,    INVALID}},
	{L"\\Kappa",       {m_ATOM,    INVALID}},
	{L"\\Lambda",      {m_ATOM,    INVALID}},
	{L"\\Mu",          {m_ATOM,    INVALID}},
	{L"\\Nu",          {m_ATOM,    INVALID}},
	{L"\\Pi",          {m_ATOM,    INVALID}},
	{L"\\Rho",         {m_ATOM,    INVALID}},
	{L"\\Sigma",       {m_ATOM,    INVALID}},
	{L"\\Tau",         {m_ATOM,    INVALID}},
	{L"\\Upsilon",     {m_ATOM,    INVALID}},
	{L"\\Phi",         {m_ATOM,    INVALID}},
	{L"\\Chi",         {m_ATOM,    INVALID}},
	{L"\\Psi",         {m_ATOM,    INVALID}},
	{L"\\Omega",       {m_ATOM,    INVALID}},
	{L"\\Xi",          {m_ATOM,    INVALID}},
		
	// ------------ Other alphabetic symbols	
		
	{L"\\aleph",       {m_ATOM,    INVALID}},
	{L"\\beth",        {m_ATOM,    INVALID}},
	{L"\\gimel",       {m_ATOM,    INVALID}},
	{L"\\daleth",      {m_ATOM,    INVALID}},
		
	{L"\\wp",          {m_ATOM,    INVALID}},
	{L"\\AA",          {m_ATOM,    INVALID}},		// is only valid in text mode in real LaTeX
	{L"\\ell",         {m_ATOM,    INVALID}},
	{L"\\P",           {m_ATOM,    INVALID}},
	{L"\\imath",       {m_ATOM,    INVALID}},
	{L"\\forall",      {m_ATOM,    INVALID}},
	{L"\\exists",      {m_ATOM,    INVALID}},
	{L"\\Finv",        {m_ATOM,    INVALID}},
	{L"\\Game",        {m_ATOM,    INVALID}},
	{L"\\partial",     {m_ATOM,    INVALID}},
		
	// ------------ Arrows
		
	{L"\\leftarrow",              {m_ATOM,    INVALID}},
	{L"\\rightarrow",             {m_ATOM,    INVALID}},
	{L"\\gets",                   {m_ATOM,    INVALID}}, // "\leftarrow" with overset superscripts
	{L"\\to",                     {m_ATOM,    INVALID}}, // "\rightarrow" with overset superscripts
	{L"\\longleftarrow",          {m_ATOM,    INVALID}},
	{L"\\longrightarrow",         {m_ATOM,    INVALID}},
	{L"\\Leftarrow",              {m_ATOM,    INVALID}},
	{L"\\Rightarrow",             {m_ATOM,    INVALID}},
	{L"\\Longleftarrow",          {m_ATOM,    INVALID}},
	{L"\\Longrightarrow",         {m_ATOM,    INVALID}},	
	{L"\\mapsto",                 {m_ATOM,    INVALID}},
	{L"\\longmapsto",             {m_ATOM,    INVALID}},
	{L"\\leftrightarrow",         {m_ATOM,    INVALID}},
	{L"\\Leftrightarrow",         {m_ATOM,    INVALID}},
	{L"\\longleftrightarrow",     {m_ATOM,    INVALID}},		// not in texvc
	{L"\\Longleftrightarrow",     {m_ATOM,    INVALID}},
		
	{L"\\uparrow",                {m_ATOM,    INVALID}},
	{L"\\Uparrow",                {m_ATOM,    INVALID}},
	{L"\\downarrow",              {m_ATOM,    INVALID}},
	{L"\\Downarrow",              {m_ATOM,    INVALID}},
	{L"\\updownarrow",            {m_ATOM,    INVALID}},
	{L"\\Updownarrow",            {m_ATOM,    INVALID}},
		
	{L"\\searrow",                {m_ATOM,    INVALID}},
	{L"\\nearrow",                {m_ATOM,    INVALID}},
	{L"\\swarrow",                {m_ATOM,    INVALID}},
	{L"\\nwarrow",                {m_ATOM,    INVALID}},
		
	{L"\\hookrightarrow",         {m_ATOM,    INVALID}},
	{L"\\hookleftarrow",          {m_ATOM,    INVALID}},
	{L"\\upharpoonright",         {m_ATOM,    INVALID}},
	{L"\\upharpoonleft",          {m_ATOM,    INVALID}},
	{L"\\downharpoonright",       {m_ATOM,    INVALID}},
	{L"\\downharpoonleft",        {m_ATOM,    INVALID}},
	{L"\\rightharpoonup",         {m_ATOM,    INVALID}},
	{L"\\rightharpoondown",       {m_ATOM,    INVALID}},
	{L"\\leftharpoonup",          {m_ATOM,    INVALID}},
	{L"\\leftharpoondown",        {m_ATOM,    INVALID}},
		
	{L"\\nleftarrow",             {m_ATOM,    INVALID}},
	{L"\\nrightarrow",            {m_ATOM,    INVALID}},
		
	// ------------ Named functions/operators
		
	{L"\\lim",                    {m_ATOM,    INVALID}},
	{L"\\sup",                    {m_ATOM,    INVALID}},
	{L"\\inf",                    {m_ATOM,    INVALID}},
	{L"\\limsup",                 {m_ATOM,    INVALID}},
	{L"\\liminf",                 {m_ATOM,    INVALID}},
	{L"\\injlim",                 {m_ATOM,    INVALID}},
	{L"\\projlim",                {m_ATOM,    INVALID}},
		
	{L"\\ker",                    {m_ATOM,    INVALID}},
	{L"\\Pr",                     {m_ATOM,    INVALID}},
	{L"\\hom",                    {m_ATOM,    INVALID}},
	{L"\\dim",                    {m_ATOM,    INVALID}},
	{L"\\arg",                    {m_ATOM,    INVALID}},
		
	{L"\\sin",                    {m_ATOM,    INVALID}},
	{L"\\cos",                    {m_ATOM,    INVALID}},
	{L"\\sec",                    {m_ATOM,    INVALID}},
	{L"\\csc",                    {m_ATOM,    INVALID}},
	{L"\\tan",                    {m_ATOM,    INVALID}},
	{L"\\cot",                    {m_ATOM,    INVALID}},
	{L"\\arcsin",                 {m_ATOM,    INVALID}},
	{L"\\arccos",                 {m_ATOM,    INVALID}},
	{L"\\arcsec",                 {m_ATOM,    INVALID}},
	{L"\\arccsc",                 {m_ATOM,    INVALID}},
	{L"\\arctan",                 {m_ATOM,    INVALID}},
	{L"\\arccot",                 {m_ATOM,    INVALID}},
	{L"\\sinh",                   {m_ATOM,    INVALID}},
	{L"\\cosh",                   {m_ATOM,    INVALID}},
	{L"\\tanh",                   {m_ATOM,    INVALID}},
	{L"\\coth",                   {m_ATOM,    INVALID}},
		
	{L"\\log",                    {m_ATOM,    INVALID}},
	{L"\\lg",                     {m_ATOM,    INVALID}},
	{L"\\ln",                     {m_ATOM,    INVALID}},
	{L"\\exp",                    {m_ATOM,    INVALID}},
		
	{L"\\sgn",                    {m_ATOM,    INVALID}},
	{L"\\min",                    {m_ATOM,    INVALID}},
	{L"\\max",                    {m_ATOM,    INVALID}},
	{L"\\gcd",                    {m_ATOM,    INVALID}},
	{L"\\deg",                    {m_ATOM,    INVALID}},
	{L"\\det",                    {m_ATOM,    INVALID}},
		
	{L"\\Re",                     {m_ATOM,    INVALID}},
	{L"\\Im",                     {m_ATOM,    INVALID}},
		
	// ------------ Binary relations
		
	{L"\\supset",                 {m_ATOM,    INVALID}},
	{L"\\subset",                 {m_ATOM,    INVALID}},
	{L"\\supseteq",               {m_ATOM,    INVALID}},
	{L"\\subseteq",               {m_ATOM,    INVALID}},
	{L"\\sqsupset",               {m_ATOM,    INVALID}},
	{L"\\sqsubset",               {m_ATOM,    INVALID}},
	{L"\\sqsupseteq",             {m_ATOM,    INVALID}},
	{L"\\sqsubseteq",             {m_ATOM,    INVALID}},
	{L"\\supsetneq",              {m_ATOM,    INVALID}},
	{L"\\subsetneq",              {m_ATOM,    INVALID}},
		
	{L"\\in",                     {m_ATOM,    INVALID}},
	{L"\\ni",                     {m_ATOM,    INVALID}},
	{L"\\notin",                  {m_ATOM,    INVALID}},
		
	{L"\\iff",                    {m_ATOM,    INVALID}},
		
	{L"\\sim",                    {m_ATOM,    INVALID}},
	{L"\\simeq",                  {m_ATOM,    INVALID}},
	{L"\\approx",                 {m_ATOM,    INVALID}},
	{L"\\propto",                 {m_ATOM,    INVALID}},
	{L"\\equiv",                  {m_ATOM,    INVALID}},
	{L"\\cong",                   {m_ATOM,    INVALID}},
	{L"\\neq",                    {m_ATOM,    INVALID}},
		
	{L"\\ll",                     {m_ATOM,    INVALID}},
	{L"\\gg",                     {m_ATOM,    INVALID}},
	{L"\\geq",                    {m_ATOM,    INVALID}},
	{L"\\leq",                    {m_ATOM,    INVALID}},
	{L"\\triangleleft",           {m_ATOM,    INVALID}},
	{L"\\triangleright",          {m_ATOM,    INVALID}},
	{L"\\trianglelefteq",         {m_ATOM,    INVALID}},
	{L"\\trianglerighteq",        {m_ATOM,    INVALID}},
		
	{L"\\models",                 {m_ATOM,    INVALID}},
	{L"\\vdash",                  {m_ATOM,    INVALID}},
	{L"\\Vdash",                  {m_ATOM,    INVALID}},
	{L"\\vDash",                  {m_ATOM,    INVALID}},
		
	{L"\\lesssim",                {m_ATOM,    INVALID}},
	{L"\\nless",                  {m_ATOM,    INVALID}},
	{L"\\ngeq",                   {m_ATOM,    INVALID}},
	{L"\\nleq",                   {m_ATOM,    INVALID}},
		
	// ----------- Binary operators
		
	{L"\\times",                  {m_ATOM,    INVALID}},
	{L"\\div",                    {m_ATOM,    INVALID}},
	{L"\\wedge",                  {m_ATOM,    INVALID}},
	{L"\\vee",                    {m_ATOM,    INVALID}},
	{L"\\oplus",                  {m_ATOM,    INVALID}},
	{L"\\otimes",                 {m_ATOM,    INVALID}},
	{L"\\cap",                    {m_ATOM,    INVALID}},
	{L"\\cup",                    {m_ATOM,    INVALID}},
	{L"\\sqcap",                  {m_ATOM,    INVALID}},
	{L"\\sqcup",                  {m_ATOM,    INVALID}},
	{L"\\smile",                  {m_ATOM,    INVALID}},
	{L"\\frown",                  {m_ATOM,    INVALID}},
	{L"\\smallsmile",             {m_ATOM,    INVALID}},
	{L"\\smallfrown",             {m_ATOM,    INVALID}},

	{L"\\setminus",               {m_ATOM,    INVALID}},
	{L"\\smallsetminus",          {m_ATOM,    INVALID}},
		
	{L"\\And",                    {m_ATOM,    INVALID}},
		
	// ---------------- Large operators
		
	{L"\\sum",                    {m_ATOM,    INVALID}},
	{L"\\prod",                   {m_ATOM,    INVALID}},
	{L"\\int",                    {m_ATOM,    INVALID}},
	{L"\\iint",                   {m_ATOM,    INVALID}},
	{L"\\iiint",                  {m_ATOM,    INVALID}},
	{L"\\iiiint",                 {m_ATOM,    INVALID}},
	{L"\\oint",                   {m_ATOM,    INVALID}},
		
	{L"\\bigcap",                 {m_ATOM,    INVALID}},
	{L"\\bigodot",                {m_ATOM,    INVALID}},
	{L"\\bigcup",                 {m_ATOM,    INVALID}},
	{L"\\bigotimes",              {m_ATOM,    INVALID}},
	{L"\\coprod",                 {m_ATOM,    INVALID}},
	{L"\\bigsqcup",               {m_ATOM,    INVALID}},
	{L"\\bigoplus",               {m_ATOM,    INVALID}},
	{L"\\bigvee",                 {m_ATOM,    INVALID}},
	{L"\\biguplus",               {m_ATOM,    INVALID}},
	{L"\\bigwedge",               {m_ATOM,    INVALID}},
		
	// ---------------- Other assorted symbols
		
	{L"\\star",                   {m_ATOM,    INVALID}},
	{L"\\triangle",               {m_ATOM,    INVALID}},
	{L"\\wr",                     {m_ATOM,    INVALID}},
	{L"\\textvisiblespace",       {m_ATOM,    t_ATOM}},
	{L"\\infty",                  {m_ATOM,    INVALID}},
	{L"\\circ",                   {m_ATOM,    INVALID}},
	{L"\\hbar",                   {m_ATOM,    INVALID}},
	{L"\\lnot",                   {m_ATOM,    INVALID}},
	{L"\\nabla",                  {m_ATOM,    INVALID}},
	{L"\\prime",                  {m_ATOM,    INVALID}},
	{L"\\backslash",              {m_ATOM,    INVALID}},
	{L"\\pm",                     {m_ATOM,    INVALID}},
	{L"\\mp",                     {m_ATOM,    INVALID}},
	{L"\\emptyset",               {m_ATOM,    INVALID}},
	{L"\\varnothing",             {m_ATOM,    INVALID}},
	{L"\\O",                      {m_ATOM,    t_ATOM}},
	{L"\\S",                      {m_ATOM,    t_ATOM}},
	{L"\\angle",                  {m_ATOM,    INVALID}},
	{L"\\colon",                  {m_ATOM,    INVALID}},
	{L"\\Diamond",                {m_ATOM,    INVALID}},
	{L"\\nmid",                   {m_ATOM,    INVALID}},	
	{L"\\square",                 {m_ATOM,    INVALID}},
	{L"\\Box",                    {m_ATOM,    INVALID}},
	{L"\\checkmark",              {m_ATOM,    INVALID}},
	{L"\\complement",             {m_ATOM,    INVALID}},
	{L"\\eth",                    {m_ATOM,    INVALID}},
	{L"\\hslash",                 {m_ATOM,    INVALID}},
	{L"\\mho",                    {m_ATOM,    INVALID}},
		
	{L"\\flat",                   {m_ATOM,    INVALID}},
	{L"\\sharp",                  {m_ATOM,    INVALID}},
	{L"\\natural",                {m_ATOM,    INVALID}},
	{L"\\bullet",                 {m_ATOM,    INVALID}},
	{L"\\dagger",                 {m_ATOM,    INVALID}},
	{L"\\ddagger",                {m_ATOM,    INVALID}},
		
	{L"\\clubsuit",               {m_ATOM,    INVALID}},
	{L"\\spadesuit",              {m_ATOM,    INVALID}},
	{L"\\heartsuit",              {m_ATOM,    INVALID}},
	{L"\\diamondsuit",            {m_ATOM,    INVALID}},
		
	{L"\\top",                    {m_ATOM,    INVALID}},
	{L"\\perp",                   {m_ATOM,    INVALID}},
		
	{L"\\ldots",                  {m_ATOM,    INVALID}},
	{L"\\cdot",                   {m_ATOM,    INVALID}},
	{L"\\cdots",                  {m_ATOM,    INVALID}},
	{L"\\vdots",                  {m_ATOM,    INVALID}},
	{L"\\ddots",                  {m_ATOM,    INVALID}},
};

hash_table<latex_command_info> latex_command_table(latex_command_data,
	latex_command_data + sizeof(latex_command_data)/sizeof(latex_command_data[0]));
	
/* This table is used by split_into_tokens() to expand aliases (i.e. macros).
The command in the first column is replaced by the text in the second column. */

dictionary_item<wstring> alias_data[] = {
	{L"\\reals",     L"{\\mathbb{R}}"},
	{L"\\Reals",     L"{\\mathbb{R}}"},
	{L"\\R",         L"{\\mathbb{R}}"},
	{L"\\cnums",     L"{\\mathbb{C}}"},
	{L"\\Complex",   L"{\\mathbb{C}}"},
	{L"\\Z",         L"{\\mathbb{Z}}"},
	{L"\\natnums",   L"{\\mathbb{N}}"},
	{L"\\N",         L"{\\mathbb{N}}"},
	{L"\\Bbb",       L"\\mathbb"},
	{L"\\bold",      L"\\mathbf"},
	{L"\\frak",      L"\\mathfrak"},
	{L"\\hbox",      L"\\mbox"},
	{L"\\vbox",      L"\\mbox"},
	{L"\\alefsym",   L"\\aleph"},
	{L"\\alef",      L"\\aleph"},
	{L"\\larr",      L"\\leftarrow"},
	{L"\\rarr",      L"\\rightarrow"},
	{L"\\Larr",      L"\\Leftarrow"},
	{L"\\lArr",      L"\\Leftarrow"},
	{L"\\Rarr",      L"\\Rightarrow"},
	{L"\\rArr",      L"\\Rightarrow"},
	{L"\\uarr",      L"\\uparrow"},
	{L"\\uArr",      L"\\Uparrow"},
	{L"\\Uarr",      L"\\Uparrow"},
	{L"\\darr",      L"\\downarrow"},
	{L"\\dArr",      L"\\Downarrow"},
	{L"\\Darr",      L"\\Downarrow"},
	{L"\\lrarr",     L"\\leftrightarrow"},
	{L"\\harr",      L"\\leftrightarrow"},
	{L"\\Lrarr",     L"\\Leftrightarrow"},
	{L"\\Harr",      L"\\Leftrightarrow"},
	{L"\\lrArr",     L"\\Leftrightarrow"},
	{L"\\hAar",      L"\\Leftrightarrow"},
	{L"\\sub",       L"\\subset"},
	{L"\\supe",      L"\\supseteq"},
	{L"\\sube",      L"\\subseteq"},
	{L"\\infin",     L"\\infty"},
	{L"\\lang",      L"\\langle"},
	{L"\\rang",      L"\\rangle"},
	{L"\\real",      L"\\Re"},
	{L"\\image",     L"\\Im"},
	{L"\\ge",        L"\\geq"},
	{L"\\le",        L"\\leq"},
	{L"\\bull",      L"\\bullet"},
	{L"\\weierp",    L"\\wp"},
	{L"\\and",       L"\\wedge"},
	{L"\\land",      L"\\wedge"},
	{L"\\or",        L"\\vee"},
	{L"\\lor",       L"\\vee"},
	{L"\\isin",      L"\\in"},
	{L"\\plusmn",    L"\\pm"},
	{L"\\bot",       L"\\perp"},
	{L"\\Dagger",    L"\\ddagger"},
	{L"\\exist",     L"\\exists"},
	{L"\\ne",        L"\\neq"},
	{L"\\empty",     L"\\emptyset"},
	{L"\\sect",      L"\\S"},
	{L"\\implies",   L"\\Longrightarrow"},
	{L"\\clubs",     L"\\clubsuit"},
	{L"\\spades",    L"\\spadesuit"},
	{L"\\hearts",    L"\\heartsuit"},
	{L"\\diamonds",  L"\\diamondsuit"},
	{L"\\part",      L"\\partial"},
	{L"\\dots",      L"\\ldots"},
	{L"\\dotsb",     L"\\cdots"},
	{L"\\sdot",      L"\\cdot"},
	// temporary: until we can work out how to really do continued fractions
	{L"\\cfrac",     L"\\frac"},
	{L"\\ang",       L"\\angle"},
	{L"\\lVert",     L"\\Vert"},
	{L"\\rVert",     L"\\Vert"},
	{L"\\|",         L"\\Vert"},
	{L"\\thetasym",  L"\\theta"},
	{L"\\neg",       L"\\lnot"},
	{L"\\mid",       L"{\\,|\\,}"},
	{L"\\varlimsup", L"\\limsup"},	// need to fix these up too
	{L"\\varliminf", L"\\liminf"},	// need to fix these up too
	{L"\\varinjlim", L"\\injlim"},	// need to fix these up too
	{L"\\varprojlim",L"\\projlim"},	// need to fix these up too
};

hash_table<wstring> alias_table(alias_data, alias_data + sizeof(alias_data)/sizeof(alias_data[0]));

/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Tokenizing stuff */

// The sequence of input tokens, generated by split_into_tokens().
vector<wstring> input_tokens;

/* split_into_tokens splits the input into tokens, each represented by a string. There are
several types:

- single characters like "a", or "{", or single unicode characters
- alphabetic commands like "\frac"
- commands like "\," which have a single nonalphabetic character after the backslash
- commands like "\   " which have their whitespace collapsed, stored as "\ "
- other consecutive whitespace characters which get collapsed to just " "
- the sequence "\begin   {  stuff}" gets stored as "\begin{  stuff}"; similarly for "\end"

It also expands aliases (e.g. "\Z" becomes "{\mathbb{Z}}").

It also picks up the special command "\displayed", which switches from inline to displayed
mode. This probably won't exist if/when blahtex is actually used in a production setting. */

void split_into_tokens(const wstring& input, vector<wstring>& output) {
	wstring::const_iterator ptr = input.begin();
	while (ptr != input.end()) {
		// merge adjacent whitespace
		if (iswspace(*ptr)) {
			output.push_back(L" ");
			do ptr++; while (ptr != input.end() && iswspace(*ptr));
		}
		// boring single character tokens
		else if (*ptr != L'\\') output.push_back(wstring(1, *ptr++));
		else {
			// tokens starting with backslash
			wstring token = L"\\";
			
			if (++ptr == input.end()) throw user_error(L"Illegal backslash at end of input.");
			if (is_plain_alpha(*ptr)) {
				// plain alphabetic commands
				do token += *ptr++; while (ptr != input.end() && is_plain_alpha(*ptr));
				
				// "\begin" and "\end" need special treatment
				if (token == L"\\begin" || token == L"\\end") {
					wstring temp = token;
					// skip whitespace between "\begin" and "{"
					while (ptr != input.end() && iswspace(*ptr)) ptr++;
					if (ptr == input.end() || *ptr != L'{') throw user_error(
						L"The command \"" + temp + L"\" was not followed by an opening brace.");
					token += *ptr++;
					while (ptr != input.end() && *ptr != L'}') token += *ptr++;
					if (ptr == input.end()) throw user_error(
						L"The environment name following \"" + temp +
						L"\" is not terminated by a closing brace.");
					token += *ptr++;
				}
			}
			else if (iswspace(*ptr)) {
				// commands like "\\ "
				token += L" ";
				do ptr++; while (ptr != input.end() && iswspace(*ptr));
			}
			// commands like "\\,"
			else token += *ptr++;
			
			if (token == L"\\displayed") mode_displayed = true;
			else {				
				// recurse into aliases
				const wstring* replacement = alias_table.lookup(token);
				if (replacement != NULL) split_into_tokens(*replacement, output);
				else output.push_back(token);
			}
		}
	}
}

/* yylex() pulls strings from "input_tokens" and uses "latex_command_table" to work out which
corresponding tokens codes to send to yyparse().

It uses the flag "in_text_mode" to decide whether to emit math mode token codes (like m_ATOM) or
text ones (like t_ATOM). The flag is controlled by yyparse(), which has better information about
when text mode is being entered or left.

There are a few extra complications that yylex() has to deal with:

- A few whitespace issues. It skips all whitespace in math mode, and some types of whitespace in
  text mode (for example the whitespace in "\mbox{abc\textbf   {xyz}}")
- Latex command with optional arguments, the only example supported now is "\sqrt". Whenever such
  a command is encountered, yylex decides (by looking ahead) whether the optional argument is
  present. If necessary, it transparently converts the opening and closing square brackets to curly
  braces, and reports that "\sqrt" is a one or two argument command as appropriate. The net effect
  is that yyparse() can be completely oblivious to commands with optional arguments, which makes
  writing the parser grammar much simpler.
*/

int yylex() {
	static bool first_call = true;

	static vector<wstring>::iterator next_token;
	static bool finished;
	static bool optional_argument_coming_up;
	static stack<bool> in_optional_argument;
	
	if (first_call) {
		first_call = false;
		finished = false;
		optional_argument_coming_up = false;
		in_optional_argument.push(false);
		next_token = input_tokens.begin();
	}
	
	if (finished) return 0;
	
	if (!in_text_mode)
		// skip whitespace in math mode
		while (next_token != input_tokens.end() && *next_token == L" ") next_token++;
	
	if (next_token == input_tokens.end()) {
		finished = true;
		return END_OF_INPUT;
	}

	// Tell yyparse() about the string corresponding to the current token
	wstring& this_token = *next_token;
	yylval.terminal_string = &(*next_token);
	next_token++;
	
	if (!in_text_mode) {
		if (optional_argument_coming_up) {
			// Convert opening "[" of optional argument to an opening brace
			in_optional_argument.push(true);
			optional_argument_coming_up = false;
			return m_BEGIN_GROUP;
		}
		
		if (in_optional_argument.top() && this_token == L"]") {
			// Convert closing "[" of optional argument to a closing brace
			in_optional_argument.pop();
			return m_END_GROUP;
		}
	}
	
	const latex_command_info* result = latex_command_table.lookup(this_token);
	if (result == NULL) {
		if (this_token[0] == L'\\')
			throw user_error(L"Unrecognised command \"" + this_token + L"\".");

		// Handle single characters that don't appear in the list of commands/special characters.
		return in_text_mode ? t_ATOM : m_ATOM;
	}
	
	if (in_text_mode) {
		if (result->text_token == INVALID)
			throw user_error(L"The command \"" + this_token + L"\" is not allowed in text mode.");

		// Skip whitespace in text mode in things like "\textbf  {...}"
		if (result->text_token == t_DECLARATION || result->text_token == t_COMMAND_1ARG)
			while (next_token != input_tokens.end() && *next_token == L" ") next_token++;

		return result->text_token;
	}
	else {
		// math mode
				
		if (result->math_token == INVALID)
			throw user_error(L"The command \"" + this_token + L"\" is not allowed in math mode.");
		
		switch (result->math_token) {
			// Opening brace
			case m_BEGIN_GROUP: {
				in_optional_argument.push(false);
				return m_BEGIN_GROUP;
			}
				
			// Closing brace
			case m_END_GROUP: {
				if (in_optional_argument.top())
					throw user_error(L"Closing curly brace encountered during optional argument.");
				in_optional_argument.pop();
				if (in_optional_argument.empty()) throw user_error(L"Too many curly close braces.");
				return m_END_GROUP;
			}
				
			// Handle commands with optional arguments (e.g. "\sqrt")
			case m_COMMAND_1OPT_1ARG: {
				while (next_token != input_tokens.end() && *next_token == L" ") next_token++;
				if (next_token == input_tokens.end()) throw user_error(
					L"The command \"" + this_token + L"\" was not followed by an argument.");

				// Determine whether this command has an optional argument or not.
				if (*next_token == L"[") {
					optional_argument_coming_up = true;
					return m_COMMAND_2ARGS;
				}
				else return m_COMMAND_1ARG;
			}
		
			// Commands like "\mbox" or "\textrm" which enter text mode
			case m_ENTER_TEXT_MODE: {
				while (next_token != input_tokens.end() && *next_token == L" ") next_token++;
				return m_ENTER_TEXT_MODE;
			}

			// All other commands/characters
			default: return result->math_token;
		}
	}
}

/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
end of file */
